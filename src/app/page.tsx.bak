"use client"

import { useState, useEffect, useCallback, useRef } from "react"
import { Download, Eye, RefreshCw, Code, Save, FolderOpen, FileText, Loader2, Wand2 } from "lucide-react"
import { OpenAI } from "openai"
import { AdminDetailsModal } from "@/components/admin-details-modal"
import FileExplorer from "@/components/file-explorer"
import { CodeEditor } from "@/components/code-editor"
import { RevisionModal } from "@/components/revision-modal"
import { Changelog } from "@/components/changelog"
import { Button } from "@/components/ui/button"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Card } from "@/components/ui/card"
import { RichTextarea } from "@/components/rich-textarea"
import { PluginDetailsModal, type PluginDetails } from "@/components/plugin-details-modal"
import { PreviewModal } from "@/components/preview-modal"
import { createWordPressInstance, installPlugin, deleteWordPressInstance } from "@/lib/instawp"
import mammoth from "mammoth"
import { CodeSnippetModal } from "@/components/code-snippet-modal"
import { ModelSelector } from "@/components/ModelSelector"
import { PluginDiscussion } from "@/components/plugin-discussion"
import { processFile } from "@/lib/file-processor"
import type { FileReference, FileStructure, Message, ChatMessage, CodeVersion, ProcessedFile, CompletePluginState } from "@/types/shared"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { VersionUpdateModal } from "@/components/version-update-modal"
import { config } from "@/config/env"
import { Tooltip, TooltipContent, TooltipTrigger, TooltipProvider } from "@/components/ui/tooltip"
import { FileDropZone } from '@/components/file-drop-zone'
import { v4 as uuidv4 } from 'uuid'
import { generateResponse } from "@/lib/ollama"

interface ChangelogEntry {
  id: string
  date: string
  description: string
  files?: string[]
  aiResponse?: string
  codeChanges?: string
  llmUsed?: string
}

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: config.OPENAI_API_KEY,
  dangerouslyAllowBrowser: true,
})

export default function PluginGenerator() {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [description, setDescription] = useState("")
  const [revisionDescription, setRevisionDescription] = useState("")
  const [generatedCode, setGeneratedCode] = useState("")
  const [pluginName, setPluginName] = useState("my-plugin")
  const [selectedFile, setSelectedFile] = useState<string | null>(null)
  const [fileStructure, setFileStructure] = useState<FileStructure[]>([])
  const [previewSiteId, setPreviewSiteId] = useState<string | null>(null)
  const [isCreatingPreview, setIsCreatingPreview] = useState(false)
  const [showAdminModal, setShowAdminModal] = useState(false)
  const [attachedFiles, setAttachedFiles] = useState<File[]>([])
  const [revisionFiles, setRevisionFiles] = useState<File[]>([])
  const [changelog, setChangelog] = useState<ChangelogEntry[]>([])
  const [showPluginDetailsModal, setShowPluginDetailsModal] = useState(false)
  const [pluginDetails, setPluginDetails] = useState<PluginDetails | null>(null)
  const [hasFilledDetails, setHasFilledDetails] = useState(false)
  const [isPreviewModalOpen, setIsPreviewModalOpen] = useState(false)
  const [previewUrl, setPreviewUrl] = useState<string | null>(null)
  const [isCodeSnippetModalOpen, setIsCodeSnippetModalOpen] = useState(false)
  const [showRevisionModal, setShowRevisionModal] = useState(false)
  const [isRevisionInputActive, setIsRevisionInputActive] = useState(false)
  const [selectedModel, setSelectedModel] = useState<string>("openai")
  const [messages, setMessages] = useState<Message[]>([])
  const [codeVersions, setCodeVersions] = useState<CodeVersion[]>([])
  const [currentVersionIndex, setCurrentVersionIndex] = useState<number>(-1)
  const [showVersionUpdateModal, setShowVersionUpdateModal] = useState(false)
  const [pendingCodeUpdate, setPendingCodeUpdate] = useState<string | null>(null)
  const [isStreaming, setIsStreaming] = useState(false)
  const [updatedFiles, setUpdatedFiles] = useState<Record<string, { added: number; deleted: number }>>({})
  const tempMessageIdRef = useRef<string | null>(null)

  useEffect(() => {
    const handleBeforeUnload = () => {
      if (previewSiteId) {
        deleteSite(previewSiteId)
      }
    }

    window.addEventListener("beforeunload", handleBeforeUnload)

    return () => {
      window.removeEventListener("beforeunload", handleBeforeUnload)
      if (previewSiteId) {
        deleteSite(previewSiteId)
      }
    }
  }, [previewSiteId])

  const deleteSite = async (siteId: string) => {
    try {
      await deleteWordPressInstance(siteId)
      console.log("Preview site deleted successfully")
    } catch (error) {
      console.error("Error deleting preview site:", error)
    }
  }

  const addCodeVersion = (code: string, description: string = '', versionNumber?: string) => {
    const versionString = versionNumber || `v${(codeVersions.length + 1).toString().padStart(2, '0')}`
    
    // Track changes if there's a previous version
    if (codeVersions.length > 0) {
      const previousCode = codeVersions[codeVersions.length - 1].code
      trackFileChanges(previousCode, code)
    }
    
    const versionEntry: CodeVersion = {
      id: Date.now().toString(),
      version: versionString,
      code,
      timestamp: new Date().toISOString(),
      description
    }
    
    const updatedVersions = [...codeVersions, versionEntry]
    setCodeVersions(updatedVersions)
    setCurrentVersionIndex(updatedVersions.length - 1)
    
    // Update plugin details with new version
    if (pluginDetails && versionNumber) {
      setPluginDetails({
        ...pluginDetails,
        version: versionNumber
      })
    }
    
    // Add a message to indicate the new version
    const versionMessage: Message = {
      id: Date.now().toString(),
      content: `Created version ${versionEntry.version} (${new Date(versionEntry.timestamp).toLocaleString()})${description ? `: ${description}` : ''}`,
      type: "assistant",
      timestamp: new Date().toISOString(),
      codeUpdate: true
    }
    setMessages(prev => [versionMessage, ...prev])
  }

  const revertToVersion = (versionId: string) => {
    const versionIndex = codeVersions.findIndex(v => v.id === versionId)
    if (versionIndex !== -1) {
      const version = codeVersions[versionIndex]
      setGeneratedCode(version.code)
      createFileStructure(version.code)
      setCurrentVersionIndex(versionIndex)
      
      // Add a message to indicate the reversion
      const revertMessage: Message = {
        id: Date.now().toString(),
        content: `Reverted to ${version.version} (${new Date(version.timestamp).toLocaleString()})`,
        type: "assistant",
        timestamp: new Date().toISOString(),
        codeUpdate: true
      }
      setMessages(prev => [revertMessage, ...prev])
    }
  }

  const revertBySteps = (steps: number) => {
    const targetIndex = currentVersionIndex - steps
    if (targetIndex >= 0 && targetIndex < codeVersions.length) {
      const version = codeVersions[targetIndex]
      setGeneratedCode(version.code)
      createFileStructure(version.code)
      setCurrentVersionIndex(targetIndex)
      
      // Add a message to indicate the reversion
      const revertMessage: Message = {
        id: Date.now().toString(),
        content: `Reverted back ${steps} version${steps === 1 ? '' : 's'} to ${version.version} (${new Date(version.timestamp).toLocaleString()})`,
        type: "assistant",
        timestamp: new Date().toISOString(),
        codeUpdate: true
      }
      setMessages(prev => [revertMessage, ...prev])
      return true
    }
    return false
  }

  const generateCode = async () => {
    try {
      if (!description && attachedFiles.length === 0) {
        setError("Please enter a description or attach files.")
        return
      }

      if (!pluginDetails) {
        setError("Plugin details are required.")
        return
      }

      setLoading(true)
      setError(null)
      setIsStreaming(true)

      let fullRequest = description

      if (attachedFiles.length > 0) {
        for (const file of attachedFiles) {
          // Cast to ProcessedFile to access imageUrl and imageAnalysis
          const processedFile = file as unknown as ProcessedFile;
          
          if (processedFile.imageUrl && processedFile.imageAnalysis) {
            // Handle image files with analysis
            fullRequest += `\n\nImage content (${file.name}): ${processedFile.imageAnalysis}`
          } else if (file.type === "application/vnd.openxmlformats-officedocument.wordprocessingml.document") {
            const arrayBuffer = await file.arrayBuffer()
            const result = await mammoth.extractRawText({ arrayBuffer })
            fullRequest += "\n" + result.value
          } else if (file.type === "text/plain") {
            const text = await file.text()
            fullRequest += "\n" + text
          } else if (processedFile.metadata?.content) {
            // Use metadata content if available
            fullRequest += `\n\n${processedFile.metadata.content}`
          }
        }
      }

      const messages = [
        {
          role: "system",
          content: `You are an expert WordPress plugin developer. Generate a complete, functional WordPress plugin. The response should be ONLY the plugin code, without any markdown formatting or explanation. The code must:
1. Start with the standard WordPress plugin header comment
2. Begin with <?php on the first line
3. Follow WordPress coding standards
4. Include proper security checks and initialization
5. Be production-ready and fully functional`,
        },
        {
          role: "user",
          content: `Create a WordPress plugin with these details:
Name: ${pluginDetails.name}
Plugin URI: ${pluginDetails.uri}
Description: ${pluginDetails.description}
Version: ${pluginDetails.version}
Author: ${pluginDetails.author}

Functionality: ${fullRequest}`,
        },
      ]

      let generatedCode = ""
      let tempCode = ""

      if (selectedModel === "openai") {
        if (!process.env.NEXT_PUBLIC_OPENAI_API_KEY) {
          throw new Error("OpenAI API key is not configured")
        }

        const openai = new OpenAI({
          apiKey: process.env.NEXT_PUBLIC_OPENAI_API_KEY,
          dangerouslyAllowBrowser: true,
        })

        const completion = await openai.chat.completions.create({
          model: "gpt-4",
          messages: messages.map(msg => ({
            role: msg.role,
            content: msg.content
          })) as { role: "system" | "user" | "assistant"; content: string }[],
          stream: true,
        })

        for await (const chunk of completion) {
          const content = chunk.choices[0]?.delta?.content || ''
          if (content) {
            tempCode += content
            setGeneratedCode(tempCode)
          }
        }
        generatedCode = tempCode
      } else if (selectedModel === "anthropic") {
        const tempMessageId = tempMessageIdRef.current
        const response = await fetch("/api/anthropic", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            messages,
          }),
        })

        if (!response.ok) {
          const errorData = await response.text()
          throw new Error(`Anthropic API error: ${errorData || response.statusText}`)
        }

        // Handle streaming response
        const reader = response.body?.getReader()
        if (!reader) throw new Error("No response stream available")

        const decoder = new TextDecoder()
        tempCode = ""

        while (true) {
          const { done, value } = await reader.read()
          if (done) break

          const chunk = decoder.decode(value)
          const lines = chunk.split('\n').filter(Boolean)

          for (const line of lines) {
            if (line.startsWith('event: chunk')) {
              try {
                const dataLine = lines.find(l => l.startsWith('data:'))
                if (dataLine) {
                  const data = JSON.parse(dataLine.slice(5))
                  if (data.text) {
                    tempCode += data.text
                    setGeneratedCode(tempCode)
                  }
                }
              } catch (e) {
                console.error('Error parsing chunk:', e)
              }
            } else if (line.startsWith('event: error')) {
              const dataLine = lines.find(l => l.startsWith('data:'))
              if (dataLine) {
                try {
                  const data = JSON.parse(dataLine.slice(5))
                  throw new Error(data.error || 'Unknown error')
                } catch (e) {
                  throw new Error('Error in stream: ' + e)
                }
              }
            } else if (line.startsWith('event: end')) {
              setIsStreaming(false)
            }
          }
        }
        
        generatedCode = tempCode
      } else if (selectedModel === "deepseek") {
        tempCode = ""
        
        try {
          const response = await fetch("/api/generate", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              messages,
              model: selectedModel,
            }),
          })

          if (!response.ok) {
            const errorText = await response.text()
            let errorMessage = "Failed to generate code: " + response.status
            try {
              const errorJson = JSON.parse(errorText)
              errorMessage += " - " + (errorJson.error || errorText)
            } catch (e) {
              errorMessage += " - " + errorText
            }
            throw new Error(errorMessage)
          }

          const reader = response.body?.getReader()
          if (!reader) throw new Error("No response stream available")

          const decoder = new TextDecoder()
          let buffer = ""
          
          while (true) {
            const { done, value } = await reader.read()
            if (done) break

            buffer += decoder.decode(value, { stream: true })
            const lines = buffer.split('\n')
            buffer = lines.pop() || ""

            for (const line of lines) {
              const trimmedLine = line.trim()
              if (!trimmedLine || !trimmedLine.startsWith('data: ')) continue

              try {
                const data = JSON.parse(trimmedLine.slice(6))
                if (data.content) {
                  tempCode += data.content
                  setGeneratedCode(tempCode)
                }
                if (data.error) {
                  throw new Error(data.error)
                }
              } catch (e) {
                console.error('Error parsing chunk:', e)
              }
            }
          }
          
          generatedCode = tempCode
        } catch (error) {
          console.error("DeepSeek API error:", error)
          throw error
        }
      } else {
        throw new Error(`Unsupported model: ${selectedModel}`)
      }

      // Clean up the generated code
      generatedCode = generatedCode
        .replace(/^```(?:php)?\s*|\s*```$/g, "")
        .replace(/^[\s\S]*?<\?php/, "<?php")
        .replace(/\n<\?php/g, "")
        .trim()

      if (!generatedCode.startsWith("<?php")) {
        generatedCode = "<?php\n" + generatedCode
      }

      setGeneratedCode(generatedCode)
      createFileStructure(generatedCode)
      addCodeVersion(generatedCode, description || 'Initial plugin generation')
    } catch (err) {
      console.error("Error generating code:", err)
      setError(`Error generating code: ${err instanceof Error ? err.message : "Unknown error"}`)
    } finally {
      setLoading(false)
      setIsStreaming(false)
    }
  }

  const generateAIResponse = async (
    userMessage: string,
    currentCode: string,
  ): Promise<{ message: string; codeUpdate?: string }> => {
    let response = ""
    const systemMessage: ChatMessage = {
        role: "system",
      content: `You are a WordPress plugin development expert. Your task is to help create or modify WordPress plugins based on user requirements. Current plugin code:\n\n${currentCode}`,
    }
    const userMsg: ChatMessage = {
        role: "user",
        content: userMessage,
    }
    const messages: ChatMessage[] = [systemMessage, userMsg]

    try {
      if (selectedModel === "openai") {
        const completion = await openai.chat.completions.create({
          model: "gpt-4",
          messages: messages.map(msg => ({
            role: msg.role,
            content: msg.content
          })) as { role: "system" | "user" | "assistant"; content: string }[],
        })
        response = completion.choices[0].message.content || ""
      } else if (selectedModel === "deepseek") {
        const result = await fetch("/api/generate", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            messages,
            model: selectedModel,
          }),
        })

        if (!result.ok) {
          throw new Error("Failed to generate response")
        }

        const data = await result.json()
        response = data.content
      } else {
        throw new Error(`Unsupported model: ${selectedModel}`)
      }

        return parseAIResponse(response)
    } catch (error) {
      console.error("Error generating response:", error)
      throw error
    }
  }

  const parseAIResponse = (response: string): { message: string; codeUpdate?: string } => {
    const codeBlockRegex = /```(?:php)?\s*([\s\S]*?)```/
    const match = response.match(codeBlockRegex)

    if (match) {
      const code = match[1]
        .replace(/^[\s\S]*?<\?php\s*/m, "<?php\n")
        .replace(/\n<\?php/g, "")
        .trim()

      const message = response.replace(codeBlockRegex, "").trim()

      if (!code.includes("Plugin Name:") && generatedCode.includes("Plugin Name:")) {
        const existingHeader = generatedCode.match(/\/\*[\s\S]*?\*\//)?.[0] || ""
        return {
          message,
          codeUpdate: `${existingHeader}\n\n${code}`,
        }
      }

      return {
        message,
        codeUpdate: code.startsWith("<?php") ? code : `<?php\n${code}`,
      }
    }

    return {
      message: response,
    }
  }

  const createFileStructure = (code: string) => {
    // Reset the updated files when creating a new file structure
    setUpdatedFiles({})
    
    // Existing code for creating file structure
    const files: FileStructure[] = []
    const mainFile: FileStructure = {
      name: `${pluginName}.php`,
      type: "file",
      content: code,
    }
    files.push(mainFile)

    // Extract includes and requires
    const includeRegex = /(?:include|require|include_once|require_once)\s*\(\s*(?:plugin_dir_path\s*\(\s*__FILE__\s*\)\s*\.\s*['"](.+?)['"]|['"](.+?)['"])\s*\)/g
    let match
    while ((match = includeRegex.exec(code)) !== null) {
      const includePath = match[1] || match[2]
      if (includePath) {
        addFileToStructure(files, includePath, "")
      }
    }

    // Extract class definitions and create files for them
    const classRegex = /class\s+(\w+)/g
    while ((match = classRegex.exec(code)) !== null) {
      const className = match[1]
      if (className && className !== "WP") {
        // Skip WordPress core classes
        const classCode = extractClassCode(code, className)
        if (classCode) {
          const filePath = `includes/class-${className.toLowerCase()}.php`
          addFileToStructure(files, filePath, classCode)
        }
      }
    }

    // Extract JavaScript code
    const jsRegex = /(?:wp_enqueue_script|wp_register_script).*?['"].*?\.js['"]/g
    while ((match = jsRegex.exec(code)) !== null) {
      const jsPath = "assets/js/script.js"
      addFileToStructure(
        files,
        jsPath,
        `// JavaScript for ${pluginName} plugin
document.addEventListener('DOMContentLoaded', function() {
  console.log('${pluginName} plugin initialized');
});`
      )
    }

    // Extract CSS code
    const cssRegex = /(?:wp_enqueue_style|wp_register_style).*?['"].*?\.css['"]/g
    while ((match = cssRegex.exec(code)) !== null) {
      const cssPath = "assets/css/style.css"
      addFileToStructure(
        files,
        cssPath,
        `/* CSS for ${pluginName} plugin */
.${pluginName}-container {
  padding: 20px;
  background-color: #f9f9f9;
  border: 1px solid #ddd;
  border-radius: 4px;
}`
      )
    }

    setFileStructure(files)
    if (files.length > 0 && files[0].type === "file") {
      setSelectedFile(files[0].name)
    }
  }

  // Track file changes between versions
  const trackFileChanges = (oldCode: string, newCode: string) => {
    const newChanges: Record<string, { added: number; deleted: number }> = {}
    
    // Compare main plugin file
    const mainFileName = `${pluginName}.php`
    const oldLines = oldCode.split('\n').length
    const newLines = newCode.split('\n').length
    const diff = newLines - oldLines
    
    if (diff !== 0) {
      newChanges[mainFileName] = {
        added: diff > 0 ? diff : 0,
        deleted: diff < 0 ? Math.abs(diff) : 0
      }
    }
    
    // For simplicity, we'll just mark files as changed if they exist in the new structure
    // In a real implementation, you would do a more detailed diff analysis
    const oldStructure = getFileStructureMap(fileStructure)
    const tempStructure: FileStructure[] = []
    createTempFileStructure(newCode, tempStructure)
    const newStructure = getFileStructureMap(tempStructure)
    
    // Find new or modified files
    Object.keys(newStructure).forEach(path => {
      if (!oldStructure[path]) {
        // New file
        const lineCount = newStructure[path].content?.split('\n').length || 0
        newChanges[path] = { added: lineCount, deleted: 0 }
      } else if (oldStructure[path].content !== newStructure[path].content) {
        // Modified file
        const oldLineCount = oldStructure[path].content?.split('\n').length || 0
        const newLineCount = newStructure[path].content?.split('\n').length || 0
        const lineDiff = newLineCount - oldLineCount
        
        newChanges[path] = {
          added: lineDiff > 0 ? lineDiff : 0,
          deleted: lineDiff < 0 ? Math.abs(lineDiff) : 0
        }
      }
    })
    
    // Find deleted files
    Object.keys(oldStructure).forEach(path => {
      if (!newStructure[path]) {
        const lineCount = oldStructure[path].content?.split('\n').length || 0
        newChanges[path] = { added: 0, deleted: lineCount }
      }
    })
    
    setUpdatedFiles(newChanges)
  }
  
  // Helper function to create a temporary file structure without updating state
  const createTempFileStructure = (code: string, files: FileStructure[]) => {
    const mainFile: FileStructure = {
      name: `${pluginName}.php`,
      type: "file",
      content: code,
    }
    files.push(mainFile)

    // Extract includes and requires
    const includeRegex = /(?:include|require|include_once|require_once)\s*\(\s*(?:plugin_dir_path\s*\(\s*__FILE__\s*\)\s*\.\s*['"](.+?)['"]|['"](.+?)['"])\s*\)/g
    let match
    while ((match = includeRegex.exec(code)) !== null) {
      const includePath = match[1] || match[2]
      if (includePath) {
        addFileToStructure(files, includePath, "")
      }
    }

    // Extract class definitions and create files for them
    const classRegex = /class\s+(\w+)/g
    while ((match = classRegex.exec(code)) !== null) {
      const className = match[1]
      if (className && className !== "WP") {
        // Skip WordPress core classes
        const classCode = extractClassCode(code, className)
        if (classCode) {
          const filePath = `includes/class-${className.toLowerCase()}.php`
          addFileToStructure(files, filePath, classCode)
        }
      }
    }
  }
  
  // Helper function to convert file structure to a map for easier comparison
  const getFileStructureMap = (structure: FileStructure[]): Record<string, FileStructure> => {
    const map: Record<string, FileStructure> = {}
    
    const processItem = (item: FileStructure, path: string = '') => {
      const fullPath = path ? `${path}/${item.name}` : item.name
      
      if (item.type === 'file') {
        map[fullPath] = { ...item }
      }
      
      if (item.type === 'folder' && item.children) {
        item.children.forEach(child => processItem(child, fullPath))
      }
    }
    
    structure.forEach(item => processItem(item))
    return map
  }

  const handlePreview = async () => {
    if (!generatedCode || !pluginName) {
      setError("Please generate code and enter a plugin name before previewing.")
      return
    }

    setLoading(true)
    setError(null)
    setIsCreatingPreview(true)

    try {
      const instance = await createWordPressInstance(pluginName)
      await installPlugin(instance.id, generatedCode, pluginName)
      setPreviewUrl(instance.adminUrl)
      setPreviewSiteId(instance.id)
      setIsPreviewModalOpen(true)
    } catch (err) {
      console.error("Error creating preview:", err)
      setError(`Error creating preview site: ${err instanceof Error ? err.message : "Unknown error"}`)
    } finally {
      setLoading(false)
      setIsCreatingPreview(false)
    }
  }

  const handleClosePreview = async () => {
    setIsPreviewModalOpen(false)
    if (previewSiteId) {
      try {
        await deleteWordPressInstance(previewSiteId)
        setPreviewSiteId(null)
        setPreviewUrl(null)
      } catch (error) {
        console.error("Error deleting preview site:", error)
      }
    }
  }

  const downloadPlugin = async () => {
    if (!generatedCode || !pluginName) {
      setError("Please generate code and enter a plugin name before downloading.")
      return
    }

    setLoading(true)
    setError(null)

    try {
      const response = await fetch("/api/generate/export-plugin", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          pluginName,
          code: generatedCode,
          structure: pluginDetails?.structure || "simplified"
        }),
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const blob = await response.blob()
      if (blob.size === 0) {
        throw new Error("Received empty response from server")
      }

      const url = window.URL.createObjectURL(blob)
      const link = document.createElement("a")
      link.href = url
      link.download = `${pluginName}.zip`
      document.body.appendChild(link)
      link.click()
      link.remove()
      window.URL.revokeObjectURL(url)
    } catch (err) {
      console.error("Download error:", err)
      setError(`Error downloading plugin: ${err instanceof Error ? err.message : "Unknown error"}`)
    } finally {
      setLoading(false)
    }
  }

  const handleSendMessage = async (content: string, files?: File[]) => {
    if (!content.trim() && (!files || files.length === 0)) return

    const timestamp = new Date().toISOString()
    const messageId = uuidv4()
    const tempMessageId = uuidv4()
    tempMessageIdRef.current = tempMessageId

    let messageContent = content
    let imageUrls: string[] = []
    let imageAnalysis: string[] = []
    
    const userMessage: Message = {
      id: messageId,
      content: messageContent,
      type: "user",
      timestamp,
    }

    if (files && files.length > 0) {
      console.log("Processing files for message:", files.length, "files")
      const processedFiles: FileReference[] = []
      
      for (const file of files) {
        try {
          // Cast to ProcessedFile to access imageUrl and imageAnalysis
          const processed = file as unknown as ProcessedFile
          
          console.log("Processing file in handleSendMessage:", file.name, processed)
          
          // Add to processed files if metadata exists
          if (processed.metadata) {
            if (processed.metadata.content) {
              messageContent += "\n\nContent from " + file.name + ":\n" + processed.metadata.content
            }
            
            processedFiles.push({
              name: processed.metadata.name,
              type: processed.metadata.type,
              content: processed.metadata.content || "",
              summary: processed.metadata.summary || "",
              isReference: true
            })
          }
          
          // Handle image files
          if (processed.imageUrl) {
            console.log("Adding image URL to message:", processed.imageUrl)
            imageUrls.push(processed.imageUrl)
            
            if (processed.imageAnalysis) {
              console.log("Adding image analysis to message:", processed.imageAnalysis)
              imageAnalysis.push(processed.imageAnalysis)
            } else {
              // Add placeholder if no analysis
              imageAnalysis.push("No analysis available for this image")
            }
          }
        } catch (error) {
          console.error(`Error processing file ${file.name}:`, error)
        }
      }
      
      userMessage.files = processedFiles
      userMessage.content = messageContent
      
      // Add image URLs and analysis to the message if present
      if (imageUrls.length > 0) {
        console.log("Adding image URLs to message:", imageUrls.length)
        userMessage.imageUrls = imageUrls
        
        if (imageAnalysis.length > 0) {
          userMessage.imageAnalysis = imageAnalysis
        }
      }
    }

    const tempMessage: Message = {
      id: tempMessageId,
      content: "",
      type: "assistant",
      timestamp: new Date().toISOString(),
    }
    
    setMessages(prev => {
      const uniqueMessages = Array.from(new Map(prev.map(msg => [msg.id, msg])).values())
      return [tempMessage, userMessage, ...uniqueMessages]
    })
    
    try {
      // Get the last 10 messages for context
      const recentMessages = messages.slice(0, 10).reverse()
      
      const conversationHistory: ChatMessage[] = [
        {
          role: "system" as const,
          content: `You are a WordPress plugin development expert. Your task is to help create or modify WordPress plugins based on user requirements. 
Remember previous interactions within this session.

Current plugin code:
${generatedCode}

Current plugin version: ${pluginDetails?.version || '1.0.0'}
Plugin name: ${pluginDetails?.name || pluginName}`,
        },
        ...recentMessages.map(msg => ({
          role: msg.type === "user" ? ("user" as const) : ("assistant" as const),
          content: msg.content
        })),
        {
          role: "user" as const,
          content: messageContent,
        }
      ]

      let tempResponse = ""
      let codeBlock = ""
      let isInCodeBlock = false
      let lastUpdateTime = Date.now()
      const updateInterval = 200

      if (selectedModel === "openai") {
        const completion = await openai.chat.completions.create({
          model: "gpt-4",
          messages: conversationHistory,
          stream: true,
        })

        for await (const chunk of completion) {
          const content = chunk.choices[0]?.delta?.content || ''
          if (content) {
            tempResponse += content
            
            if (content.includes('```')) {
              isInCodeBlock = !isInCodeBlock
            } else if (isInCodeBlock) {
              codeBlock += content
            }
            
            const now = Date.now()
            if (now - lastUpdateTime >= updateInterval && tempMessageIdRef.current === tempMessageId) {
              setMessages(prev => {
                const uniqueMessages = Array.from(new Map(prev.map(msg => [msg.id, msg])).values())
                return uniqueMessages.map(msg => 
                  msg.id === tempMessageId 
                    ? { ...msg, content: tempResponse }
                    : msg
                )
              })
              lastUpdateTime = now
            }
          }
        }
      } else if (selectedModel === "anthropic") {
        const response = await fetch("/api/anthropic", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            messages: conversationHistory,
          }),
        });

        if (!response.ok) {
          const errorData = await response.text();
          throw new Error(`Anthropic API error: ${errorData || response.statusText}`);
        }

        // Handle streaming response
        const reader = response.body?.getReader();
        if (!reader) throw new Error("No response stream available");

        const decoder = new TextDecoder();
        tempResponse = "";
        isInCodeBlock = false;
        codeBlock = "";

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value);
          const lines = chunk.split('\n').filter(Boolean);

          for (const line of lines) {
            if (line.startsWith('event: chunk')) {
              try {
                const dataLine = lines.find(l => l.startsWith('data:'));
                if (dataLine) {
                  const data = JSON.parse(dataLine.slice(5));
                  if (data.text) {
                    tempResponse += data.text;
                    
                    if (data.text.includes('```')) {
                      isInCodeBlock = !isInCodeBlock;
                    } else if (isInCodeBlock) {
                      codeBlock += data.text;
                    }
                    
                    const now = Date.now();
                    if (now - lastUpdateTime >= updateInterval && tempMessageIdRef.current === tempMessageId) {
                      setMessages(prev => {
                        const uniqueMessages = Array.from(new Map(prev.map(msg => [msg.id, msg])).values());
                        return uniqueMessages.map(msg => 
                          msg.id === tempMessageId 
                            ? { ...msg, content: tempResponse }
                            : msg
                        );
                      });
                      lastUpdateTime = now;
                    }
                  }
                }
              } catch (e) {
                console.error('Error parsing chunk:', e);
              }
            } else if (line.startsWith('event: error')) {
              const dataLine = lines.find(l => l.startsWith('data:'));
              if (dataLine) {
                try {
                  const data = JSON.parse(dataLine.slice(5));
                  throw new Error(data.error || 'Unknown error');
                } catch (e) {
                  throw new Error('Error in stream: ' + e);
                }
              } else if (line.startsWith('event: end')) {
                setIsStreaming(false);
              }
          }
        }
      } else {
        throw new Error(`Unsupported model: ${selectedModel}`)
      }

      if (tempMessageIdRef.current === tempMessageId) {
        const parsedResponse = parseAIResponse(tempResponse)
        
        setMessages(prev => {
          const uniqueMessages = Array.from(new Map(prev.map(msg => [msg.id, msg])).values())
          return uniqueMessages.map(msg => 
            msg.id === tempMessageId 
              ? { 
                  ...msg, 
                  content: parsedResponse.message,
                  codeUpdate: !!parsedResponse.codeUpdate
                }
              : msg
          )
        })
        
        if (parsedResponse.codeUpdate) {
          handleCodeUpdate(parsedResponse.codeUpdate)
        }
      }
    } catch (error) {
      console.error("Error generating AI response:", error)
      if (tempMessageIdRef.current === tempMessageId) {
        setMessages(prev => {
          const uniqueMessages = Array.from(new Map(prev.map(msg => [msg.id, msg])).values())
          return uniqueMessages.map(msg => 
            msg.id === tempMessageId 
              ? {
                  ...msg,
                  content: error instanceof Error ? error.message : "An error occurred",
                }
              : msg
          )
        })
      }
    } finally {
      if (tempMessageIdRef.current === tempMessageId) {
        tempMessageIdRef.current = null
      }
    }
  }

  const handleSavePlugin = () => {
    if (!generatedCode || !pluginName) {
      setError("Please generate code and enter a plugin name before saving.")
      return
    }

    const completeState: CompletePluginState = {
      id: Date.now().toString(),
      name: pluginName,
      code: generatedCode,
      description: description,
      date: new Date().toISOString(),
      pluginDetails: pluginDetails,
      messages: messages,
      codeVersions: codeVersions,
      currentVersionIndex: currentVersionIndex,
      fileStructure: fileStructure,
      changelog: changelog
    }

    // Create a Blob from the state
    const stateBlob = new Blob([JSON.stringify(completeState, null, 2)], { type: 'application/json' })
    
    // Create download link
    const url = window.URL.createObjectURL(stateBlob)
    const link = document.createElement('a')
    link.href = url
    link.download = `${pluginName}-state.json`
    document.body.appendChild(link)
    link.click()
    link.remove()
    window.URL.revokeObjectURL(url)

    setError(null)
  }

  const handleLoadPlugin = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (!file) return

    try {
      const text = await file.text()
      const state: CompletePluginState = JSON.parse(text)

      // Restore all state
      setPluginName(state.name)
      setGeneratedCode(state.code)
      setDescription(state.description)
      setPluginDetails(state.pluginDetails)
      setMessages(state.messages)
      setCodeVersions(state.codeVersions)
      setCurrentVersionIndex(state.currentVersionIndex)
      setFileStructure(state.fileStructure)
      setChangelog(state.changelog)
      
      // Set the selected file to the main plugin file
      setSelectedFile(`${state.name}/${state.name}.php`)
      
    setError(null)
    } catch (err) {
      console.error('Error loading plugin state:', err)
      setError('Failed to load plugin state file')
    }
  }

  const updateFileStructure = (
    structure: FileStructure[],
    path: string | null,
    newContent: string,
  ): FileStructure[] => {
    if (!path) return structure

    const parts = path.split("/")
    const updateRecursive = (items: FileStructure[]): FileStructure[] => {
      return items.map((item) => {
        if (item.name === parts[0]) {
          if (parts.length === 1 && item.type === "file") {
            return { ...item, content: newContent }
          } else if (item.type === "folder" && item.children) {
            return { ...item, children: updateRecursive(item.children) }
          }
        }
        return item
      })
    }

    return updateRecursive(structure)
  }

  const handleRevisionSubmit = async (description: string, files?: File[]) => {
    setRevisionDescription(description)
    if (files) {
      setRevisionFiles(files)
    }

    if (!description && (!files || files.length === 0)) {
      setError("Please enter a revision description or attach files.")
      return
    }

    setLoading(true)
    setError(null)

    try {
      let fullRevisionRequest = `You are a WordPress plugin expert. Your task is to MODIFY the existing plugin code by ADDING the requested functionality while PRESERVING ALL existing functionality.

IMPORTANT:
1. DO NOT remove or replace existing features unless explicitly requested
2. Keep all existing functions and hooks
3. Add new functionality alongside existing code
4. Maintain the current plugin structure
5. Return the COMPLETE updated plugin code

Current plugin code:
${generatedCode}

Requested changes:
${description}

Your response must include:
1. A brief explanation of what you're adding/changing
2. How the new changes integrate with existing functionality
3. The complete updated plugin code that includes both existing and new features`

      if (files && files.length > 0) {
        for (const file of files) {
          try {
            const text = await processFile(file)
            if (text.metadata?.content) {
              fullRevisionRequest += "\n\nAdditional context from attached file:\n" + text.metadata.content
            }
          } catch (error) {
            console.error(`Error processing file ${file.name}:`, error)
            setError(`Error processing file ${file.name}. Please try again.`)
            return
          }
        }
      }

      const aiResponse = await generateAIResponse(fullRevisionRequest, generatedCode)
      let explanation = ""
      let updatedCode = ""

      // Parse the AI response to separate explanation from code
      if (aiResponse.message) {
        const parts = aiResponse.message.split("```")
        if (parts.length >= 3) {
          explanation = parts[0].trim()
          updatedCode = parts[1].replace(/^php\n/, '').trim()
        } else {
          explanation = "Changes applied as requested."
          updatedCode = aiResponse.codeUpdate || aiResponse.message
        }
      }

      if (updatedCode) {
        setGeneratedCode(updatedCode)
        createFileStructure(updatedCode)
        
        // Add a new version for this revision
        addCodeVersion(updatedCode, `${description}\n\nChanges made:\n${explanation}`)
      }

      const newEntry: ChangelogEntry = {
        id: Date.now().toString(),
        date: new Date().toLocaleDateString(),
        description: description,
        files: files?.map((f) => f.name),
        codeChanges: updatedCode,
        aiResponse: explanation,
        llmUsed: selectedModel,
      }
      setChangelog((prev) => [newEntry, ...prev])

      // Add a message to show the explanation
      const message: Message = {
        id: Date.now().toString(),
        content: `Changes applied:\n${explanation}`,
        type: "assistant",
        timestamp: new Date().toISOString(),
        codeUpdate: true
      }
      setMessages(prev => [...prev, message])

      setRevisionDescription("")
      setRevisionFiles([])
      setShowRevisionModal(false)
    } catch (err) {
      console.error("Error submitting revision:", err)
      setError(`Error submitting revision: ${err instanceof Error ? err.message : "Unknown error"}`)
    } finally {
      setLoading(false)
    }
  }

  const handleCodeUpdate = (code: string) => {
    if (!code) return;
    
    // Store the code update for later use
    setPendingCodeUpdate(code)
    
    // Show the version update modal
    setShowVersionUpdateModal(true)
  }

  const handleVersionUpdateSubmit = (newVersion: string) => {
    if (!pendingCodeUpdate) return;
    
    // Update plugin details with new version
    if (pluginDetails) {
      setPluginDetails({
        ...pluginDetails,
        version: newVersion
      })
    }
    
    // Update version in the plugin code header
    const updatedCode = pendingCodeUpdate.replace(
      /Version:\s*([0-9]+\.?)+/,
      `Version: ${newVersion}`
    )
    
    // Apply the code update
    setGeneratedCode(updatedCode)
    createFileStructure(updatedCode)
    
    // Add to version history
    addCodeVersion(updatedCode, 'AI suggested edit', newVersion)
    
    // Clear the pending update
    setPendingCodeUpdate(null)
    
    // Close the modal
    setShowVersionUpdateModal(false)
    
    // Update messages to show the code was updated
    setMessages(prev => prev.map(msg => 
      msg.type === 'assistant' && !msg.codeUpdate 
        ? { ...msg, codeUpdate: true }
        : msg
    ))
  }

  const extractCustomFunctions = (code: string) => {
    // Look for functions that aren't part of the standard plugin structure
    const functionMatches = code.match(/function\s+(?!activate_|deactivate_|run_)[\w_]+\s*\([^)]*\)\s*{[^}]*}/g) || []
    return functionMatches.join("\n\n")
  }

  // Add new function to distribute code updates
  const distributeCodeUpdates = (code: string) => {
    if (!pluginDetails || pluginDetails.structure !== "traditional") {
      return code
    }

    const pluginName = pluginDetails.name

    // Extract plugin header
    const headerMatch = code.match(/\/\*[\s\S]*?\*\//)
    const pluginHeader = headerMatch ? headerMatch[0] : ""
    
    // Extract the main functionality, excluding the header
    const mainCode = code.replace(headerMatch?.[0] || "", "").trim()

    // Extract admin-specific code
    const adminCode = extractFunctionsByPrefix(mainCode, "admin_")
    
    // Extract public-specific code
    const publicCode = extractFunctionsByPrefix(mainCode, "public_")
    
    // Extract custom functions that don't belong to admin or public
    const customFunctions = extractCustomFunctions(mainCode)

    // Update admin class file
    const adminClassPath = `${pluginName}/admin/class-admin.php`
    const adminClassContent = generateAdminClass(pluginName)
    setFileContent(adminClassPath, adminClassContent)

    // Update public class file
    const publicClassPath = `${pluginName}/public/class-public.php`
    const publicClassContent = generatePublicClass(pluginName)
    setFileContent(publicClassPath, publicClassContent)

    // Generate main plugin file
    return generateMainPluginFile(pluginHeader, customFunctions, pluginName)
  }

  // Add helper function to extract functions by prefix
  const extractFunctionsByPrefix = (code: string, prefix: string) => {
    const functionRegex = new RegExp(`function\\s+${prefix}[\\w_]+\\s*\\([^)]*\\)\\s*{[^}]*}`, 'g')
    const matches = code.match(functionRegex) || []
    return matches.join("\n\n")
  }

  // Add setFileContent function
  const setFileContent = (path: string, content: string) => {
    const findAndUpdateFile = (files: FileStructure[]): FileStructure[] => {
      return files.map(file => {
        if (file.path === path) {
          return { ...file, content }
        }
        if (file.children) {
          return { ...file, children: findAndUpdateFile(file.children) }
        }
        return file
      })
    }

    setFileStructure(prev => findAndUpdateFile(prev))
  }

  // Add effect to load chat history from localStorage on mount
  useEffect(() => {
    const savedMessages = localStorage.getItem("chatHistory")
    const savedCodeVersions = localStorage.getItem("codeVersions")
    const savedPluginDetails = localStorage.getItem("pluginDetails")
    const savedGeneratedCode = localStorage.getItem("generatedCode")
    
    if (savedMessages) {
      setMessages(JSON.parse(savedMessages))
    }
    if (savedCodeVersions) {
      setCodeVersions(JSON.parse(savedCodeVersions))
    }
    if (savedPluginDetails) {
      setPluginDetails(JSON.parse(savedPluginDetails))
    }
    if (savedGeneratedCode) {
      setGeneratedCode(savedGeneratedCode)
    }
  }, [])

  // Add effect to save chat history to localStorage when it changes
  useEffect(() => {
    localStorage.setItem("chatHistory", JSON.stringify(messages))
    localStorage.setItem("codeVersions", JSON.stringify(codeVersions))
    if (pluginDetails) {
      localStorage.setItem("pluginDetails", JSON.stringify(pluginDetails))
    }
    if (generatedCode) {
      localStorage.setItem("generatedCode", generatedCode)
    }
  }, [messages, codeVersions, pluginDetails, generatedCode])

  return (
    <div className="flex flex-col h-screen">
      <h1 className="text-2xl font-bold p-4 border-b flex-shrink-0">WordPress Plugin Generator</h1>
      <div className="flex flex-1 min-h-0">
        {/* Left Column - Chat Interface (40%) */}
        <div className="w-[40%] flex flex-col min-h-0 border-r">
          <div className="p-4 border-b flex-shrink-0">
            <div className="mb-4">
              <ModelSelector selectedModel={selectedModel} onModelChange={setSelectedModel} />
            </div>
            <div className="flex items-center gap-2 flex-wrap">
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button
                      onClick={() => {
                        if (!hasFilledDetails) {
                          setShowPluginDetailsModal(true)
                        } else {
                          generateCode()
                        }
                      }}
                      disabled={loading || isCreatingPreview}
                      className={hasFilledDetails ? "bg-emerald-600 hover:bg-emerald-700 text-white" : "bg-black hover:bg-gray-800 text-white"}
                    >
                      {loading ? (
                        <>
                          <RefreshCw className="mr-2 h-4 w-4 animate-spin" />
                          Generating...
                        </>
                      ) : hasFilledDetails ? (
                        "Generate Plugin"
                      ) : (
                        "Start"
                      )}
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>Generate a new WordPress plugin based on your description</p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>

              <input
                type="file"
                accept=".json"
                onChange={handleLoadPlugin}
                className="hidden"
                id="load-plugin-input"
              />
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button 
                      variant="outline" 
                      onClick={() => document.getElementById('load-plugin-input')?.click()}
                      disabled={loading}
                    >
                      <FolderOpen className="mr-2 h-4 w-4" />
                      Load
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>Load a previously saved plugin state</p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>

              <div className="flex gap-2">
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button onClick={downloadPlugin} variant="outline" disabled={!generatedCode}>
                        <Download className="h-4 w-4 mr-2" />
                        Download
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Download your plugin as an installable WordPress Plugin ZIP file</p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>

                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button onClick={() => setIsCodeSnippetModalOpen(true)} variant="outline" disabled={!generatedCode}>
                        <Code className="h-4 w-4 mr-2" />
                        Snippet
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>View a code snippet version of your plugin</p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>

                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button onClick={handleSavePlugin} variant="outline" disabled={!generatedCode}>
                        <Save className="h-4 w-4 mr-2" />
                        Save
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Save your plugin state to a file</p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              </div>
            </div>
          </div>
          
          {/* Plugin Discussion - Chat Interface */}
          <div className="flex-1 min-h-0 overflow-hidden">
            <PluginDiscussion
              messages={messages}
              onSendMessage={handleSendMessage}
              onCodeUpdate={handleCodeUpdate}
              className="h-full"
              selectedModel={selectedModel}
              revertBySteps={revertBySteps}
              revertToVersion={revertToVersion}
              codeVersions={codeVersions.map(v => ({ id: v.id, version: v.version, timestamp: v.timestamp }))}
              initialDescription={description}
              onInitialDescriptionChange={setDescription}
              onFilesSelected={setAttachedFiles}
            />
          </div>
        </div>

        {/* Center Column - File Explorer (20%) */}
        <div className="w-[20%] border-r flex flex-col min-h-0">
          <div className="p-2 border-b flex-shrink-0">
            <h2 className="text-sm font-semibold">Files</h2>
          </div>
          <div className="flex-1 overflow-auto">
            <FileExplorer
              files={fileStructure}
              selectedFile={selectedFile}
              onSelectFile={setSelectedFile}
              updatedFiles={updatedFiles}
            />
          </div>
          {codeVersions.length > 0 && (
            <div className="p-2 border-t">
              <div className="flex items-center gap-2">
                <span className="text-xs font-medium">Version:</span>
                <Select
                  value={currentVersionIndex.toString()}
                  onValueChange={(value) => {
                    const version = codeVersions[parseInt(value)]
                    if (version) {
                      revertToVersion(version.id)
                    }
                  }}
                >
                  <SelectTrigger className="h-8 text-xs">
                    <SelectValue placeholder="Select version" />
                  </SelectTrigger>
                  <SelectContent>
                    {codeVersions.map((version, index) => (
                      <SelectItem key={version.id} value={index.toString()}>
                        {version.version} ({new Date(version.timestamp).toLocaleString()})
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
            </div>
          )}
        </div>

        {/* Right Column - Code Display (40%) */}
        <div className="w-[40%] flex flex-col min-h-0">
          <div className="p-2 border-b flex-shrink-0 flex justify-between items-center">
            <h2 className="text-sm font-semibold">
              {selectedFile ? selectedFile : "Code"}
            </h2>
            {selectedFile && (
              <div className="flex gap-2">
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button onClick={handlePreview} variant="outline" size="sm" disabled={!generatedCode || isCreatingPreview}>
                        <Eye className="h-4 w-4 mr-1" />
                        Preview
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Preview your plugin in a WordPress environment</p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button onClick={() => setShowRevisionModal(true)} variant="outline" size="sm" disabled={!generatedCode}>
                        <Wand2 className="h-4 w-4 mr-1" />
                        Revise
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Request specific changes to your plugin</p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              </div>
            )}
          </div>
          <div className="flex-1 min-h-0">
            <CodeEditor
              selectedFile={selectedFile}
              fileStructure={fileStructure}
              loading={loading}
              streaming={isStreaming}
              onCodeChange={(newCode) => {
                if (selectedFile === `${pluginName}/${pluginName}.php`) {
                  setGeneratedCode(newCode)
                }
                const updatedStructure = updateFileStructure(fileStructure, selectedFile, newCode)
                setFileStructure(updatedStructure)
              }}
            />
          </div>
        </div>
      </div>

      {/* Modals */}
      <CodeSnippetModal
        isOpen={isCodeSnippetModalOpen}
        onClose={() => setIsCodeSnippetModalOpen(false)}
        code={generatedCode}
      />

      <VersionUpdateModal
        isOpen={showVersionUpdateModal}
        onClose={() => setShowVersionUpdateModal(false)}
        onSubmit={handleVersionUpdateSubmit}
        currentVersion={codeVersions[currentVersionIndex]?.version || "1.0.0"}
      />

      <PluginDetailsModal
        isOpen={showPluginDetailsModal}
        onClose={() => setShowPluginDetailsModal(false)}
        onSubmit={(details) => {
          setPluginDetails(details)
          setPluginName(details.name)
          setHasFilledDetails(true)
          setShowPluginDetailsModal(false)
          generateCode()
        }}
      />

      <RevisionModal
        isOpen={showRevisionModal}
        onClose={() => setShowRevisionModal(false)}
        onSubmit={handleRevisionSubmit}
        pluginName={pluginName}
      />

      <PreviewModal
        isOpen={isPreviewModalOpen}
        onClose={handleClosePreview}
        previewUrl={previewUrl}
      />

      {error && (
        <div className="fixed bottom-4 right-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
          {error}
        </div>
      )}
    </div>
  )
}

